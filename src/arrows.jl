## ----

"""
    quiver!([p::Plot], x, y, txt=nothing; quiver=(dx, dy), kwargs...)
    quiver(x, y, txt=nothing; quiver=(dx, dy), kwargs...)

Draw 2d arrows. See `arrow!` for a single arrow.

* `(x,y)` are tail positions, optionally labeled by `txt`
* `quiver` specifies vector part of arrow
* `kwargs process `arrowhead::Int?`, `arrowwidth::Int?`, `arrowcolor`

# Example

```julia
ts = range(0, 2pi, length=100)
p = plot(sin.(ts), cos.(ts), linecolor="red")
ts = range(0, 2pi, length=10)
quiver!(p, cos.(ts), sin.(ts), quiver=(-sin.(ts), cos.(ts)), arrowcolor="red")
p
```

This example shows how text can be rotated with angles in degrees and positive angles measured in a *clockwise* direction.

```
ts = range(0, 2pi, 100)
p = plot(cos.(ts), sin.(ts), linecolor="red", aspect_ratio=:equal,
    linewidth=20, opacity=0.2)

txt = split("The quick brown fox jumped over the lazy dog")
ts = range(0, 360, length(txt)+1)[2:end]
for (i,t) ∈ enumerate(reverse(ts))
    quiver!(p, [cosd(t)],[sind(t)],txt[i],
            quiver=([0],[0]),
            textangle=90-t,
            font=(size=20,))
end
xaxis!(zeroline=false); yaxis!(zeroline=false) # remove zerolines
p
```

!!! note "3d arrows"
    3d arrows are possible using `arrows!`.

"""
function quiver!(p::Plot, x, y, txt=nothing; quiver=nothing, kwargs...)
    us = zip(x,y)
    dus = zip(quiver...)
    as = _arrow.(us, dus, txt; kwargs...)
    if isempty(p.layout.annotations)
        p.layout.annotations = Config[]
    end
    append!(p.layout.annotations, as)
    p
end
quiver!(x, y, txt=nothing; quiver=nothing, kwargs...) =
    quiver!(current_plot[], x, y, txt; quiver=quiver, kwargs...)

function quiver(as...; kwargs...)
    p = _new_plot(; kwargs...)
    quiver!(p, as...; kwargs...)
end

# Makie style
"""
    arrows(x, y, [z], f::Function; kwargs...)
    arrows(x, y, [z], u, v, [w]; kwargs...)
    arrows!([p::Plot], x, y, [z], f::Function; kwargs...)
    arrows!([p::Plot], x, y, [z], u, v, [w]; kwargs...)

Draw arrows from `x-y-[z]` with lengths `u-v-w` (or optionally generated by `f`).

# Example
```
plot(;xlims=(-5,5), ylims=(-5,5))
f(x,y) = (-y,x)./sqrt(1 + x^2 + y^2)
grid = tuple.((-5:5)', (-5:5))
arrows!(unzip(grid)..., f)
```
"""
function arrows(x,y,f::Function; kwargs...)
    p = _new_plot(; kwargs...)
    arrows!(p, x, y, f; kwargs...)
end
arrows!(x,y,f::Function; kwargs...) =
    arrows!(current_plot[], x, y, f; kwargs...)

function arrows!(p::Plot, x,y,f::Function; kwargs...)
    u,v = unzip(f.(x,y))
    arrows!(p, x,y,u,v; kwargs...)
end

function arrows(x,y,z,f::Function; kwargs...)
    p = _new_plot(; kwargs...)
    arrows!(p, x, y, z, f; kwargs...)
end
arrows!(x,y,z,f::Function; kwargs...) =
    arrows!(current_plot[], x, y, z, f; kwargs...)

function arrows!(p::Plot, x,y,z,f::Function; kwargs...)
    u,v,w = unzip(f.(x,y,z))
    arrows!(p, x,y,z,u,v,w; kwargs...)
end

function arrows(x,y,u,v; kwargs...)
    p = _new_plot(; kwargs...)
    arrows!(p, x, y, u, v; kwargs...)
end
arrows!(x,y,u,v; kwargs...) =
    arrows!(current_plot[], x,y,u,v; kwargs...)
function arrows!(p::Plot, x,y,u,v; kwargs...)
    quiver!(p, x, y, quiver=(u,v); kwargs...)
end

function arrows(x,y,z,u,v,w; kwargs...)
    p = _new_plot(; kwargs...)
    arrows!(p, x, y, z, u, v, w; kwargs...)
end
arrows!(x,y,z,u,v,w; kwargs...) = arrows!(current_plot[], x,y,z,u,v,w; kwargs...)
function arrows!(p::Plot, x,y,z,u,v,w; kwargs...)
    # call arrow!(p, t,v)
    for (t̂, v̂) ∈ zip(zip(x,y,z), zip(u,v,w))
        arrow!(p, t̂, v̂; kwargs...)
    end
    p
end


# quiver, arrows work on vectors x,y,z,u,v,w
# arrow works on vectors of (x,y,z), (u,v,w) points
# quiver only 2d
# work in tail, Δ form
"""
    arrow(tails, vs; kwargs...)

Draw vectors `vs` anchored at `tails`.
Hacked in support for 3D using combination of lines + cones.

Use `Plotly` attributes `arrowcolor`, `arrowwidth`,
"""
function arrow(tails, vs; kwargs...)
    p = _new_plot(; kwargs...)
    arrow!(p, tails, vs; kwargs...)
    p
end

arrow!(tails, vs; kwargs...) = arrow!(current_plot[], tails, vs; kwargs...)

function arrow!(p::Plot, tails, vs; kwargs...)
    # what kind of data two points or
    # vectors of points
    _tail = first(tails)
    if isa(_tail, Number)
        N = length(tails)
        tails = [tails]
        vs = [vs]
    else
        __tail = first(_tail)
        !isa(__tail, Number) && throw(ArgumentError("Not a point or container of points"))
        N = length(_tail)
    end
    arrow!(p, Val(N), tails, vs; kwargs...)
end

function arrow!(p::Plot, ::Val{2}, tails, vs; kwargs...)
    quiver!(p, unzip(tails)..., quiver=tuple(unzip(vs)...); kwargs...)
    p
end


# λ may change!
# too fiddly
function arrow!(p::Plot, ::Val{3}, tails, vs; λ = 0.1, showscale=false, kwargs...)
    _norm(x) = sqrt(sum(xᵢ*xᵢ for xᵢ ∈ x))

    tips = map(.+, tails, vs)
    x0,y0,z0 = unzip(tails)
    x1,y1,z1 = unzip(tips)
    #pad with NaN
    x = collect(Iterators.flatten([[a,b,nothing] for (a,b) ∈ zip(x0,x1)]))
    y = collect(Iterators.flatten([[a,b,nothing] for (a,b) ∈ zip(y0,y1)]))
    z = collect(Iterators.flatten([[a,b,nothing] for (a,b) ∈ zip(z0,z1)]))

    d1 = Config(;x,y,z, type="scatter3d", mode="lines", showscale, kwargs...)
    push!(p.data, d1)

    x,y,z = unzip(tips)
    du,dv,dw = unzip(vs)

    # adjust length of cone. This is fiddly
    # https://plotly.com/python-api-reference/generated/plotly.graph_objects.Cone.html


    # not sure this is better than unit vectors...
    M = maximum(_norm.(vs))
    u, v, w = du ./ M, dv ./ M, dw ./ M
    #u,v,w = du, dv, dw
    λ *= log10(10 + length(x))

    d2 = Config(;type="cone",
                x,y,z,
                u,v,w,
                anchor="tip",
                sizemode="absolute",
                sizeref=  λ*M,
                showscale,
                kwargs...)
    push!(p.data,  d2)
    p
end
